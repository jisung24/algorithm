'use strict';
// 그리디 알고리즘 
// 선택하는 상황이 계속 나오는데... 
// 미래를 생각하지 않고 현재에서 최선을 다 해서 욕심해서 선택을 해버리는 알고리즘!!!! 
// 내가 좋아하는 명언.. => 현재에 최선을 다 하자! => 이런 마인드의 알고리즘
//❗️현재의 이 선택이 최적이길 바라는 알고리즘❗️

// tip : ❗️모든 문제에서 그리디 알고리즘이 최적의 선택지는 아니야❗️
// 예를들어서 미래를 선택해야 할 그런 알고리즘으로 풀어야 하는 문제도 있어 
// ex) 지금 선택하면 1개받고 1분 뒤에 선택하면 2개받는 상황에서 그리디를 선택하는 것은 좋지 못 해! 
// ===> 그리디는 당장 지금 선택을 해야하기 때문에...

// 그럼 그리디를 써야하는 상황은 언제일까? (❗️한 번에 뭘 많이 해야 할 때❗️)

// ex) 1. 한 강의실에서 최대한 많은 수업을 동시에 해야 할 때! 
// 2. 동전을 최대한 적게 거슬러줘야 할 떄 => 현재 최대값의 동전을 최대한으로 선택하는거야! 
// --- 500원이 최대 값의 동전이면 500원을 일단 많이 선택하는거야! ==> 큰 걸 제일 많이 선택!!! 

// 3. 한 번에 무거운 무게의 물건을 먼저 가방에 넣는 문제!! 
// 즉, 내가 지금 직면한 숫자에 대해서 가장 그것들을 먼저 많이 선택해야 할 때 그리디를 쓴다! 
// 현재 이 상황(500원, 가장 큰 무게의 물건)에서 그것들을 최선을 다 해서 많이 선택해야 할 때! 
// 그래서 결국 내가 선택한 횟수를 결국 최소한으로 만드는게 greedy핵심!!!!!!!! 

// ❗️당장에 큰 걸 최대한으로 선택해서 결국 선택 횟수가 최소한이 돼야 해❗️
// 구해야 하는거! 
// 1. 일단 ts가 [1,10,50]등의 값보다 커야함! 
// 2. Math.floor()함수를 사용해 몇 번 나눌 수 있는 지 개수를 구한다. 
// 3. 횟수를 구했으면,, 전체 값에서 그 값 * 횟수 만큼을 뺀 후 다음 testcase의 값을 따진다.. 
// 4. 이걸 계속 반복한다!! 

// 5. 그리고 그리디의 값으로 나오지 못 할 경우도 고려를 해줘야 한다!!!!!! 